# DOM 계층 구조 이해하기

타입스크립트에서 DOM 엘리먼트의 계층 구조를 파악하기 용이하다.  
Element와 EventTarget에 달려 있는 Node의 구체적인 타입을 안다면 타입 오류를 디버깅할 수 있고, 언제 타입 단언을 사용해야 할지 알 수 있다.  
DOM에 접근하는 코드를 작성하면 JS에서는 문제가 발생하지 않지만, 타입스크립트에서는 수많은 오류가 표시된다.

## EventTarget 타입 관련 오류

예를 들어, HTMLParagraphElement는 HTMLElement의 서브타입이고, HTMLElement는 Element의 서브타입이다. 또한 Element는 Node의 서브타입이고, Node는 EventTarget의 서브타입이다.

### EventTarget

EventTarget은 DOM 타입 중 가장 추상화된 타입이다.  
이벤트 리스너를 추가하거나 제거하고, 이벤트를 보내는 것밖에 할 수 없다.

```typescript
function handleDrag(eDown: Event) {
  const targetEl = eDown.currentTarget;
  targetEl.classList.add("dragging");
  // 개체가 'null'인 것 같습니다.
  // 'EventTarget' 형식에 'classList' 속성이 없습니다.
}
```

- Event의 currentTarget 속성의 타입은 `EventTarget | null`이다. 그러기 때문에 null 가능성이 오류로 표시되었다.
- EventTarget 타입에 classList 속성이 없기 때문에 오류가 되었다.

### Node

예시로 document나 텍스트 노드, 주석이 있다.  
childNodes 프로퍼티는 엘리먼트뿐만 아니라 텍스트 노드와 주석까지도 포함하고 있다.

### Element, HTMLElement

SVG 태그의 전체 계층 구조를 포함하면서 HTML이 아닌 엘리먼트가 존재하는데, 바로 Element의 또 다른 종류인 SVGElement이다.  
에를 들어, `<html>`은 HTMLHtmlElement이고, `<svg>`는 SVGSvgElement이다.

### HTMLxxxElement

특정 엘리먼트들은 자신만의 고유한 속성을 가지고 있다.  
예를 들어, HTMLImageElement에는 src 속성이 있고, HTMLInputElement에는 value 속성이 있다.  
이런 속성에 접근하려면, 타입 정보 역시 실제 엘리먼트 타입이어야 하므로 상당히 구체적으로 타입을 지정해야 한다.

항상 정확한 타입을 얻을 수 있는 것은 아니다. 특히 `document.getElementById`에서 문제가 발생하게 된다.

`document.getElementById('my-div'); // HTMLElement`

일반적으로 타입 단언문은 지양해야 하지만, DOM 관련해서는 타입스크립트보다 개발자가 더 정확히 알고 있는 경우이므로 단언문을 사용해도 좋다.

`document.getElementById('my-div') as HTMLDivElement;`

strictNullChecks가 설정된 상태라면, null인 경우를 체크해야 한다. 실제 코드에서 null일 가능성이 있다면 if 분기문을 추가해야 한다.

`document.getElementById('my-div')!;`

## Event 타입 관련 오류

```typescript
function handleDrag(eDown: Event) {
  const dragStart = [eDown.clientX, eDown.clientY];
  // 'Event' 형식에 'clientX' 속성이 없습니다.
  // 'Event' 형식에 'clientY' 속성이 없습니다.
}
```

- EventTarget 타입의 계층 구조뿐 아니라, Event 타입에도 별도의 계층 구조가 있다.
- Event는 가장 추상화된 이벤트이다. 더 구체적인 타입들은 다음과 같다.
  - UIEvent: 모든 종류의 사용자 인터페이스 이벤트
  - MouseEvent: 클릭처럼 마우스로부터 발생되는 이벤트
  - KeyboardEvent: 키 누름 이벤트
- handleDrag 함수의 매개변수는 Event로 선언된 반면 clientX와 clientY는 보다 구체적인 MouseEvent 타입에 있기 때문에 오류가 발생한 것이다.
- 'mousedown' 이벤트 핸들러를 인라인 함수로 만들면 타입스크립트는 더 많은 문맥 정보를 사용하게 되고, 대부분의 오류를 제거할 수 있다.
- 또한 매개변수 타입을 Event 대신 MouseEvent로 선언할 수 있다.

# 정보를 감추는 목적으로 private 사용하지 않기

자바스크립트는 클래스에 비공개 속성을 만들 수 없다.  
많은 이가 비공개 속성임을 나타내기 위해 언더스코어(`_`)를 접두사로 붙이던 것이 관례로 인정될 뿐이었다.  
그러나 속성에 언더스코어를 붙이는 것은 단순히 비공개라고 표시한 것뿐이다.  
따라서 일반적인 속성과 동일하게 클래스 외부로 공개되어 있다는 점을 주의해야 한다.

타입스크립트에는 public, protected, private 접근 제어자를 사용해서 공개 규칙을 강제할 수 있는 것으로 오해할 수 있다.  
그러나 접근 제어자는 타입스크립트 키워드이기 때문에 컴파일 후에는 제거된다.  
그렇기에 컴파일 시점에만 오류를 표시해 줄 뿐이며, 런타임에는 아무런 효력이 없다.

즉, 정보를 숨기기 위해 private을 사용하면 안 된다. 정보를 숨기기 위해 가장 효과적인 방법은 클로저를 사용하는 것이다.  
단 숨기기 위한 정보에 접근해야 하는 메서드 역시 생성자 내부에 정의되어야 하기에 인스턴스를 생성할 때마다 메서드의 복사본이 생성되어 메모리를 낭비한다.  
또 하나의 선택지로, 비공개 필드 기능을 사용할 수 있다. 비공개 필드 기능은 접두사로 `#`를 붙여서 타입 체크와 런타임 모두에서 비공개로 만드는 역할을 한다.

# 소스맵을 사용하여 타입스크립트 디버깅하기

타입스크립트 코드를 실행한다는 것은, 엄밀히 말하자면 타입스크립트 컴파일러가 생성한 자바스크립트 코드를 실행한다는 것이다.  
컴파일러, 전처리기, 압축기 등을 통해 변환된 JS 코드는 복잡해 디버깅하기 매우 어렵다.  
디버깅 문제를 해결하기 위해 소스맵이라는 해결책이 등장했다.  
소스맵은 변환된 코드의 위치와 심벌들을 원본 코드의 원래 위치와 심벌들로 맵핑한다.

```json
{
  "compilerOptions": {
    "sourceMap": true
  }
}
```

컴파일을 실행하면 각 .ts 파일에 대해 .js와 .js.map 두 개의 파일을 생성한다. .js.map 파일이 바로 소스맵이다.

<br />
<br />
<br />

# 모던 자바스크립트로 작성하기

58장부터는 타입스크립트로 마이그레이션 하는 데에 필요한 조언들을 배울 수 있었다.  
타입스크립트는 코드를 특정 버전의 자바스크립트로 컴파일하는 기능도 가지고 있기에 트랜스파일러로 사용할 수 있다.

- ECMAScript 모듈 사용하기
- 프로토타입 대신 클래스 사용하기
- var 대신 let/const 사용하기
- for(;;) 대신 for-of 또는 배열 메서드 사용하기
- 함수 표현식보다 화살표 함수 사용하기
- 단축 객체 표현과 구조 분해 할당 사용하기
- 함수 매개변수 기본값 사용하기
- 저수준 프로미스나 콜백 대신 async/await 사용하기
- 연관 배열에 객체 대신 Map과 Set 사용하기
- 타입스크립트에 use strict 넣지 않기

# 타입스크립트 도입 전에 @ts-check와 JSDoc으로 시험해 보기

본격적으로 타입스크립트로 전환하기에 앞서, @ts-check 지시자를 사용하면 타입스크립트 전환시에 어떤 문제가 발생하는지 미리 시험해 볼 수 있다.  
@ts-check 지시자를 사용하여 타입 체커가 파일을 분석하고, 발견된 오류를 보고하도록 지시한다.  
주의할 점은 @ts-check 지시자는 매우 느슨한 수준으로 타입 체크를 수행한다는 것이다.

### 선언되지 않은 전역 변수

어딘가에 숨어 있는 변수라면, 변수를 제대로 인식할 수 있게 별도의 타입 선언 파일을 만들어야 한다.  
types.d.ts 파일을 만든 뒤 declare 키워드를 활용하여 변수를 선언하면 오류가 해결된다.

### 알 수 없는 라이브러리

서드파티 라이브러리를 사용하는 경우, 서드파티 라이브러리의 타입 정보를 알아야 한다.  
예를 들어, 제이쿼리를 사용하면 @ts-check 지시자를 사용하면 제이쿼리를 사용한 부분에서 오류가 발생한다.  
제이쿼리 타입 선언을 설치하면 제이쿼리의 사양 정보를 참조하게 된다.

### DOM 문제

JSDoc을 사용하여 타입 단언을 대체할 수 있다.

```javascript
// @ts-check
const ageEl = /** @type {HTMLInputElement} */ (document.getElementById("age"));
ageEl.value = "12";
```

### 부정확한 JSDoc

프로젝트에 이미 JSDoc 스타일의 주석을 사용 중이었다면, @ts-check 지시자를 설정하는 순간부터 기존 주석에 타입 체크가 동작하게 되고 갑자기 수많은 오류가 발생하게 될 것이다.  
이때는 당황하지 말고 타입 정보를 차근차근 추가해 나가면 된다.

# allowJs로 타입스크립트와 자바스크립트 같이 사용하기

- 점진적 마이그레이션을 위해 JS와 TS를 동시에 사용할 수 있게 allowJs 컴파일러 옵션을 사용한다.
- 대규모 마이그레이션 작업을 시작하기 전에, 테스트와 빌드 체인에 타입스크립트를 적용해야 한다.

# 의존성 관계에 따라 모듈 단위로 전환하기

점진적 마이그레이션을 할 때는 모듈 단위로 각개격파하는 것이 이상적이다.  
그런데 한 모듈을 골라서 타입 정보를 추가하면, 해당 모듈이 의존하는 모듈에서 비롯되는 타입 오류가 발생하게 된다.  
의존성과 관련된 오류 없이 작업하려면, 다른 모듈에 의존하지 않는 최하단 모듈부터 작업을 시작해서 의존성의 최상단에 있는 모듈을 마지막으로 완성해야 한다.

프로젝트 내에 존재하는 모듈은 서드파티 라이브러리에 의존하지만 서드파티 라이브러리는 해당 모듈에 의존하지 않기 때문에, 서드파티 라이브러리 타입 정보를 가장 먼저 해결해야 한다.  
일반적으로 @types 모듈을 설치하면 된다.  
외부 API를 호출하는 경우도 있기 때문에 외부 API의 타입 정보도 추가해야 한다.

마이그레이션할 때는 타입 정보 추가만 하고, 리팩터링을 해서는 안 된다.

### 선언되지 않은 클래스 멤버

자바스크립트는 클래스 멤버 변수를 선언할 필요가 없지만, 타입스크립트에서는 명시적으로 선언해야 한다.  
이는 빠른 수정 기능으로 간단히 해결할 수 있다.  
빠른 수정을 적용한 후에 속성을 훑어보고 any로 추론된 부분을 직접 수정해야 한다.  
잘못된 설계를 발견했을 때, 잘못된 설계 그대로 타입스크립트로 전환하는 것은 납득하기 어려운 일이다. 하지만 리팩터링을 하면 안 된다.

### 타입이 바뀌는 값

객체에 프로퍼티를 추가하는 코드는 JS에서는 문제 없지만, TS에서는 문제가 발생한다.  
이때 한 번에 객체를 생성하면 오류를 해결할 수 있다.  
한꺼번에 생성하기 곤란한 경우에는 임시 방편으로 타입 단언문을 사용할 수 있다. 마이그레이션이 완료된 이후에는 타입 선언문을 사용하여 문제를 제대로 해결하자.

마지막 단계로, 테스트 코드를 타입스크립트로 전환하면 된다.  
로직 코드가 테스트 코드에 의존하지 않기 때문에, 테스트 코드는 항상 의존성 관계도의 최상단에 위치하며 마이그레이션의 마지막 단계가 되는 것은 자연스러운 일이다.  
그리고 최하단의 모듈부터 TS로 전환하는 와중에도 테스트 코드는 변경되지 않았고, 테스트를 수행할 수 있었을 것이다.  
마이그레이션 기간 중에 테스트를 수행할 수 있다는 것은 엄청난 이점이다.

# 마이그레이션의 완성을 위해 noImplicitAny 설정하기

프로젝트 전체를 .ts로 전환한 뒤, 마지막 단계는 noImplicitAny를 설정하는 것이다.  
noImplicitAny가 설정되지 않은 상태에서는 타입 선언에서 비롯되는 실제 오류가 숨어 있기 때문에 마이그레이션이 완료되었다고 할 수 없다.

처음에는 noImplicitAny를 로컬에만 설정하고 작업하는 것이 좋다.  
왜냐하면 원격에서는 설정에 변화가 없기 때문에 빌드가 실패하지 않기 때문이다.  
로컬에서만 오류로 인식되기 때문에, 수정된 부분만 커밋할 수 있어서 점진적 마이그레이션이 가능하다.

엄격한 타입 체크를 적용하기 전에 팀원들이 타입스크립트에 익숙해질 수 있도록 타입 체크 설정을 점진적으로 적용해야 한다.
