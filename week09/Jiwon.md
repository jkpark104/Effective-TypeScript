# [아이템56] 정보를 감추는 목적으로 private 사용하지 않기

> ### 요약
> 1. public, protected, private 접근 제어자는 타입 시스템에서 강제될 뿐이다. 런타임에는 소용이 없으며 단언문을 통해 우회할 수도 있다. 때문에 접근 제어자로 데이터를 감추려고 해서는 안된다.
> 2. 확실히 데이터를 감추고 싶다면 클로저를 사용해야 한다.

</br>

타입스크립트에서는 `public, protected, private` 접근 제어자를 사용해서 공개 규칙을 강제할 수 있다. 
하지만 이들은 타입스크립트에 한정되므로, 컴파일 후에는 제거된다. 
때문에 타입스크립트에서 `private`으로 설정하여도 실제 자바스크립트코드에서는 접근이 가능하다.  

자바스크립트에서 정보를 숨기기 위해 가장 효과적인 방법은 `클로저`를 사용하는 것이다.
```typescript
declare function hash(text: string): number;

class PasswordChecker {

private password: string;

constructor() {

this.password = 's3cret';

}

checkPassword(password: string) {

return password === this.password;

}

}

const checker = new PasswordChecker();

const password = (checker as any).password;
```


또 다른 선택지로는 표준화가 진행 중인 비공개 필드 기능을 사용하는 것이다.
비공개 필드 기능은 접두사로 #을 붙여서 타입 체크와 런타임 모두에서 비공개로 만드는 역할을 한다.

`#passwordHash` 성은 클래스 외부에서 접근이 불가능하다. 클로저 기법과 다르게 클래스 메서드나 동일한 클래스의 개별 인스턴스끼리 접근이 가능하다.  
즉, 내부 함수가 중복적으로 생성이 되지 않으므로 좀더 효율적인 코드 작성이 가능하다. 비공개 필드를 지원하지 않는 자바스크립트 버전으로 컴파일하게되면, `WeapMap`을 사용한 구현으로 대체되고, 구현방식과 무관하게 데이터는 동일하게 비공개로 된다.  


# [아이템57] 소스맵을 사용하여 타입스크립트로 디버깅하기
> ### 요약
> 1. 원본 코드가 아닌 변환된 자바스크립트 코드를 디버깅하지 말자. 소스맵을 사용하면 런타임에 타입스크립트(원본) 코드를 디버깅 할 수 있다.
> 2. 소스맵이 최종적으로 변환된 코드에 완전히 매핑 되었는지 확인하자.
> 3. 소스맵에 원본 코드가 그대로 포함되도록 설정되었을 수도 있다. 공개되지 않도록 설정을 확인하자.

</br>

타입스크립트를 실행한다는것은 **타입스크립트가 컴파일한 자바스크립트**를 실행한다는 것이다. 
그렇지만 마치 타입스크립트가 실행되는 것처럼 느껴질수 있게 한다면 가장 이상적일 것이다.  
하지만 디버깅을 할때에는 실제 런타임 환경이므로 **전처리기, 컴파일러, 압축기를 거친 자바스크립트**을 확인하게 된다.  

이러한 자바스크립트 코드는 복잡하여 디버깅 하기 매우 어렵고 이 문제를 해결하기 위해 **브라우저 제조사**는 `소스맵`이라는 해결책을 내놓았다.

소스맵은 원본 코드의 원래 위치와 심벌들로 매핑한다. 대부분의 브라우저와 IDE는 소스맵을 지원한다.


```json
{ 
	"compilerOptions": { 
		"sourceMap": true 
	} 
}  
   
```

소스맵 설정을 추가해주면 브라우저 `개발자도구 -> Sources` 탭에서 `ts file`을 확인할 수 있다.


# [아이템58] 모던 자바스크립트로 작성하기

> ### 요약
> 1. 타입스크립트 개발 환경은 모던 자바스크립트도 실행할 수 있으므로, 모던 자바스크립트의 최신 기능들을 적극 사용하자. 
> 2. 'use strict'는 타입스크립트 컴파일러 수준에서 사용되므로 코드에서 제거해야 한다.

</br>

| 모던 자바스크립트의 기준은 ES2015(ES6) 이후 버전들을 의미.

타입스크립트는 타입 체크기능 외에, 타입스크립트 코드를 특정 버전의 자바스크립트로 컴파일하는 기능도 가지고 있다.   
즉, **타입스크립트 컴파일러를 자바스크립트 트랜스파일러로도 사용할 수 있다.**

옛날 버전의 자바스크립트 코드를 타입스크립트 컴퍼일러에서 동작하게 만들면 이후로는 최신 버전의 자바스크립트 기능을 코드에 추가해도 문제가 없다. 따라서 옛날 버전의 자바스크립트 코드를 최신 버전의 자바스크립트로 바꾸는 작업은 타입스크립크립트로 전환하는 작업의 일부로 볼 수 있다.
</br>

## 1. ECMAScript 모듈 사용하기
ES2015 이전에는 코드를 개별 모듈로 분할하는 표준 방법이 없었지만, 지금은 개별 모듈로 분할하는 방법이 많다.
ES2015부터는 `import` 와 `export`를 사용하는 ECMAScript 모듈(ES모듈)이 표준이 되었다.
ES모듈 시스템은 타입스크립트에서도 잘 동작하며, 모듈 단위로 전환할 수 있게 해 주기 때문에 점진적 마이그레이션이 원활해진다.
</br>

## 2. 프로토타입 대신 클래스 사용하기
마이그레이션 하려는 코드에서 단순한 객체를 다룰 때 프로토타입을 사용하고 있었다면, 클래스로 바꾸는 것이 좋다.
프로토타입으로 구현한 객체보다 클래스로 구현한 객체가 문법이 간결하고 직관적이다.
클래스가 익숙하지 않더라도 타입스크립트 언어 서비스를 활용하면 클래스를 간단히 작성할 수 있다.
</br>

## 3. var 대신 let/const 사용하기
`var` 키워드의 스코프 규칙에 문제가 있는 건 널리 알려진 사실.
`var` 키워드 대신 `let`, `const` 키워드를 사용한다면 문제를 피할 수 있다.
</br>

## 4. for문 대신 for-of 또는 배열 메서드 사용하기
`for-of` 루프는 코드가 짧고 인덱스 변수를 사용하지 않기 때문에 실수를 줄일 수 있다.
인덱스 변수가 필요한 경우에는 `forEach` 메서드를 사용하면 된다.
</br>

## 5. 함수 표현식보다 화살표 함수 사용하기
`this` 키워드는 일반적인 변수들과 다른 스코프 규칙을 가진다. (렉시컬 this)
화살표 함수를 사용하면 상위 스코프의 `this` 를 유지할 수 있다.
컴파일러 옵션에 `noImplicityThis`를 설정하면 타입스크립트가 `this` 바인딩 관련 오류를 표시해 주므로 설정하는 것이 좋다.
</br>

## 6. 단축 객체 표현과 구조 분해 할당 사용하기
```typescript
const x = 1, y = 2, z =3;
const pt = {
	x: x,
	y: y,
	z: z
}
```

`변수`와 객체의 `속성` 이 같다면, 간단하게 다음처럼 작성할 수 있다.
```typescript
const pt = {x, y, z};
```

</br>
화살표 함수 내에서 객체를 반환할 때는 소괄호로 감싸야 한다.
함수의 구현부에는 블록이나 단일 표현식이 필요하기 때문에 소괄호로 감싸서 표현식으로 만들어 준다.

</br>

객체의 속성 중 함수를 축약해서 표현하는 방법(메서드 축약 표현)
```typescript
const obj = {
	onClick(e) {
		//
	}
}

```

객체 구조 분해
```typescript

const props = obj;
const a = props.a;
cons b = props.b;


const {props} = obj;
const {a, b} = props;

const {props: {a,b}} = obj;
```

구조 분해 문법 내에서 기본값을 지정하는 방법
```typescript
const {a = 'defualt'} = obj.props;
```

배열 구조 분해 할당
```typescript
const point = [1, 2, 3];
const [x, y, z] = point;
```

함수의 매개변수에 구조 분해 할당 사용
```typescript
function([x,y,z]){
	//
}
```

</br>

## 7. 함수 매개변수 기본값 사용하기
자바스크립트 함수의 모든 매개변수는 선택적(생략 가능)이며, 매개변수를 지정하지 않으면 `undefined`로 간주된다.
```typescript
function parseNum (str, base = 10) {
	return parseInt(str, base);
}
```

모던 자바스크립트에서는 매개변수에 기본값을 직접 지정할 수 있다.
매개변수에 기본값을 지정하면, base가 선택적 매개변수라는 것을 명확히 나타낼 수 있고, 기본값을 기반으로 타입 추론이 가능하기 때문에 마이그레이션할 때 매개변수에 타입 구문을 쓰지 않아도 된다.

</br>

## 8. 저수준 프로미스나 콜백 대신 async/await 사용하기
async, await을 사용하면 코드가 간결해져서 버그나 실수를 방지할 수 있고, 비동기 코드에 타입 정보가 전달되어 타입 추론을 가능하게 한다.

</br>

## 9. 연관 배열에 객체 대신 Map과 Set 사용하기

## 10. 타입스크립트에 useStrict 넣지 않기
ES5에서는 버그가 될 수 있는 코드 패턴에 오류를 표시해주는 `엄격모드 (strict mode)`가 도입됨. 

```javascript
'use strict';
function foo() {
  x = 10; // strict 모드에서는 오류, non-strict 모드에서는 전역선언
}
```

타입스크립트에서 수행되는 안전성 검사(sanity check)가 엄격 모드보다 더 엄격한 체크를 하기 때문에 'use strict'는 무의미.

실제로 타입스크립트 컴파일러가 생성하는 자바스크립트 코드에서 'use strict'가 추가된다. `alwaysStrict` 또는 `strict` 컴파일러 옵션을 설정하면, 타입스크립트는 업격모드로 코드를 파싱하고 생성되는 자바스크립트에 'use stict'를 추가한다.

-> 타입스크립트 코드에 'use strict'를 쓰지 않고, 대신 `alwaysStrict` 설정을 사용하자.

# [아이템59] 타입스크립트 도입전에 @ts-check와 JSDoc으로 시험해보기


> ### 요약
> 1. 파일 상단에 @ts-check를 추가하면 자바스크립트에서도 타입 체크를 수행할 수 있다.
> 2. 전역 선언과 서드파티 라이브러리의 타입 선언을 추가하는 방법을 익히자.
> 3. JSDoc 주석을 잘 활요하면, 자바스크립트 상태에서도 타입 단언과 추론을 할 수 있다.
> 4. JSDoc 주석은 중간 단계이기 때문에 너무 공들일 필요 없다. 최종 목표는 타입스크립트 코드다.

</br>

타입스크립트 전환하기에 앞서, @ts-check 지시자를 사용하면 타입스크립트 전환시에 어떤 문제가 발생하는지 미리 시험해 볼 수 있다.  
```typescript
// @ts-check 
const person = { first: 'Grace', last: 'Hopper' }; 2 * person.first; //error 

/* const person: { 
	first: string; 
	last: string; 
 } 
 The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type. */  

```

# [아이템62] 마이그레이션의 완성을 위해 noIplicitAny 설정하기

> ### 요약
> 1. noImplicityAny 설정을 활성화하여 마이그레이션의 마지막 단계를 진행해야 한다. noImplicityAny 설정이 없다면 타입 선언과 관련된 실제 오류가 드러나지 않는다.
> 2. noImplicityAny를 전면 적용하기 전에 로컬에서부터 타입 오류를 점진적으로 수정해야 한다. 엄격한 타입 체크를 적용하기 전에 팀원들이 타입스크립트에 익숙해질 수 있도록 시간을 주자.

</br>

프로젝트 전체를 `.ts` 로 전환했다면 이제 마무리 작업으로 `tsconfig.json`옵션으로 `noIplicitAny` 설정해야한다. 우선 처음은 로컬에만 설정하고 작업하는 것이 좋다. 원격의 경우 어차피 설정에 변화가 없기 때문에 기존 빌드를 실패하지 않을 것이기 때문이다.

타입 체크의 강도는 팀 내의 모든 사람이 타입스크립트에 익숙해진 다음에 조금씩 높이는 것이 좋다.
