# 2022년 4월 6일 한결 공부내용


## 아이템 46: 타입 선언과 관련된 세 가지 버전 이해하기

- 타입스크립트를 사용하는 경우 의존성 관리를 위해 고려해야 할 것
    - 라이브러리의 버전
    - 타입선언(`@types`)의 버전
    - 타입스크립트의 버전
- 라이브러리의 버전과 타입 선언의 버전(`v16.3.7`)은 메이저, 마이너 버전(`16`, `3`)이 일치한다면 괜찮다.
    - 패치 버전(`7`)은 공개 API 사양을 변경하지 않기 때문에 타입 선언 버전과 달라도 무관
    - 그러나 이렇게 별도로 관리되는 경우 네 가지 문제점이 생긴다.
        1. 라이브러리를 업데이트했지만 타입선언이 업데이트 되지 않은 경우
        라이브러리 버전 > 타입선언 버전 : 타입 오류 또는 하위호환성 깨지는 변경 시 런타임 오류
        → 타입 선언도 라이브러리와 버전이 맞도록 업데이트
        → 해당 버전의 타입 선언이 준비되지 않았다면 라이브러리에 타입정보를 보강 기법으로 추가
        2. 라이브러리보다 타입 선언의 버전이 최신인 경우
        라이브러리 버전 < 타입선언 버전 : 뒤늦게 타입 선언을 설치해 버전 정보가 어긋남
        → 버전이 맞도록 라이브러리 또는 타입선언의 버전을 조정
        3. 프로젝트의 타입스크립트 버전보다 의존하는 라이브러리의 타입스크립트 버전이 최신인 경우
        프로젝트 TS < 라이브러리 TS : `@types` 선언 자체에서 타입오류가 발생
        → 프로젝트의 타입스크립트를 최신 버전으로 사용하는 게 가장 좋음
        → 라이브러리 타입 선언의 버전을 내리거나, `declare module`로 라이브러리의 타입 정보 삭제
        → `typesVersions`를 통해 타입스크립트 버전별로 다른 타입 선언을 제공 (매우 희귀)
        4. `@types` 의존성이 중복되는 경우
        전역 네임스페이스에 있는 타입 선언 모듈이 이렇게 의존성이 중복되면 중복된 선언 또는 선언 병합 불가 오류 발생
        → *타입 선언 중복 발생 위치를 추적하여 둘 중 하나를 업데이트하여 서로 버전이 호환되게 하기*
        → 전이(transitive) 의존성을 가지면 종종 문제를 일으키므로 피할 것 (아이템 51 참고)
- 자체적인 타입 선언 vs. DefinitelyTyped
    - 자체적 타입 선언: package.json에서 `“types”` 필드에 `{파일명}.d.ts` 파일을 지정한 경우
    - **DefinitelyTyped** is the most popular repository of Declaration Files for many many JavaScript libraries most of which do not provide their own declaration files (as they are not developed with TypeScript and are not committed to work with it).  
    → **DefinitelyTyped는 (**TypeScript**로 개발되지 않았으며 그 작업에 공들이지 않았기 때문에) 자체 선언 파일을 제공하지 않는 많은** JavaScript **라이브러리에서 가장 널리 사용되는 선언 파일 레포입니다.**
    - 결론: 자체적 타입 선언은 아래와 같이 문제가 많으니 **무조건 DefinitelyTyped 써라**
        1. 번들된 타입 선언에 보강 기법으로 해결할 수 없는 오류, 또는 TS 버전 업데이트로 인한 오류가 발생할 때 자체적으로 번들된 타입에서는 `@types`의 버전 선택이 불가
        → MS사에서 TS 버전이 올라가면 DefinitelyTyped의 타입선언을 점검하고 해결해줌
        2. 프로젝트의 타입 선언이 다른 라이브러리의 타입 선언에 의존하면 devDependency라서 설치되지 않아 타입오류가 발생 (그렇다고 JS 사용자도 있는데 dependency로 타입 선언 패키지를 포함시킬 순 없는 노릇)
        → DefinitelyTyped에서는 타입 선언이 `@types`에 있어 TS 사용자만 사용 가능
        3. 프로젝트의 과거 버전 타입 선언 문제인 경우 과거 버전으로 돌아가 패치 업데이트 해야함
        → DefinitelyTyped는 동일 라이브러리의 여러 버전의 타입 선언을 동시에 유지보수 가능
        4. 타입 선언의 패치 업데이트를 자주 하기 어려움 
        → DefinitelyTyped처럼 커뮤니티에서 관리하는 별도의 `@types` 파일이 있으면 이런 작업량을 감당할 수 있음
- 라이브러리가 TS로 작성된 경우에만 타입 선언을 라이브러리에 포함 (JS로 작성된 경우 타입 선언을 DefinitelyTyped에 공개)
    
## 아이템 47: 공개 API에 등장하는 모든 타입을 익스포트하기

- 프로젝트 초기에 타입 익스포트부터 작성하라.
- 만약 타입을 숨기고 싶어 익스포트하지 않았다 해도 어차피 추출해낼 방법이 있기 때문에 굳이 숨기려 하지 말고 명시적으로 익스포트하라
    
## 아이템 48: API 주석에 TSDoc 사용하기

- 인라인 주석 (`// 주석`내용 )으로 만들면 편집기가 툴팁으로 표시해주지 않으니 JSDoc 스타일(`/** 주석내용 */`)로 만들자.
    - JSDoc은 TS 관점에서 TSDoc이라고 부르기도 한다.
    - 주석을 md 형식으로 꾸밀 수 있다.
- `@param`나 `@returns` 등의 JSDoc 규칙을 사용하여 매개변수와 반환값에 대한 설명을 보여주게 할 수 있다.
- 타입 정의와 interface 정의 필드마다 TSDoc 스타일 주석을 달면 객체의 각 필드에 대한 설명을 볼 수 있다.

## 아이템 49: 콜백에서 this에 대한 타입 제공하기

- this는 호출 방식에 따라 다른 것을 참조하는 동적 바인딩의 특성을 가지므로 특별히 신경써야 한다.
- 라이브러리에 this를 사용하는 콜백 함수가 있다면, 콜백함수의 매개변수에 this를 추가하고, 콜백함수를 `call`로 호출하여 해결할 수 있다.
    - 콜백함수의 첫 매개변수에 있는 this는 특별하게 처리된다 → this 바인딩을 체크하고 나서 this 외의 매개변수들을 요구한다.
    - this 타입 실수 방지, this 참조 시의 문제를 타입스크립트가 잡아낸다.

## 아이템 50: 오버로딩 타입보다는 조건부 타입을 사용하기

- 함수 오버로드: **같은 이름의 함수를 중복하여 정의하는 것**
- 타입스크립트에서 함수 구현체는 하나이지만 타입 선언은 여러 개 만들 수 있다.
- 오버로딩을 통해서는 유니온 타입을 할당할 때 특정 타입이 아니기 때문에 문제 발생 
→ 삼항연산자 형태의 조건부 타입을 사용하는 것이 더 좋다.

## 아이템 51: 의존성 분리를 위해 미러 타입 사용하기
- NodeJS 사용자를 위한 타입 선언(`@types/node`)을 devDependency에 포함!
    - NodeJS와 TS를 동시에 사용하는 개발자만 이를 필요로 함
    - `@types`와 무관한 JS 개발자와 NodeJS와 무관한 TS 웹개발자는 혼란
- 작성 중인 라이브러리가 의존하는 라이브러리의 구현과 무관하게 타입에만 의존한다면, 타입선언 의존성을 추가하지 않고 필요한 선언부만 추출하여 정의하고 할당하자(미러링)

## 아이템 52: 테스팅 타입의 함정에 주의하기
- 함수 호출 테스트 파일 작성: 반환값에 대한 체크 누락
- → 반환타입을 체크하도록 함수를 변수에 할당하고 해당 변수에 타입 할당: 불필요한 변수 생성 & 객체 타입에는 의도와 달리 작동(동일성이 아닌, 할당 가능성만 체크)
- → 제너릭 타입을 이용해 매개변수 타입과 반환 타입 분리하여 테스트: this 등장시 또다른 문제 발생
- → `declare`으로 선언을 사용하여 타입체크 통과: `declare module 'overbar';`로 전체 모듈에 any 타입 할당
- 결론: DefinitelyTyped의 타입 선언을 위한 도구인 dtslint를 사용할 것

## 아이템 53: 타입스크립트 기능보다는 ECMAScript 기능을 사용하기 

## 아이템 54: 객체를 순회하는 노하우
