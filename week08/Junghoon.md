# 타입 선언과 관련된 세 가지 버전 이해하기

타입스크립트는 의존성 관리를 오히려 더 복잡하게 만든다.  
타입스크립트를 사용하면 다음 세 가지 사항을 추가로 고려해야 하기 때문이다.

- 라이브러리 버전
- 타입 선언의 버전
- 타입스크립트 버전

세 가지 버전 중 하나라도 맞지 않으면, 의존성과 상관없어 보이는 곳에서 엉뚱한 오류가 발생할 수 있다.  
타입스크립트 라이브러리 관리의 메커니즘을 이해하게 된다면 프로젝트 내에서 작성한 타입 선언을 외부에 공개해야 하는 시점이 되었을 때, 버전과 관련해서 제대로 된 결정을 내릴 수 있다.

## 라이브러리와 타입 정보의 버전이 별도로 관리되는 방식의 문제점

### 라이브러리를 업데이트했지만 실수로 타입 선언은 업데이트 하지 않는 경우

라이브러리 업데이트와 관련된 새로운 기능을 사용하려 할 때마다 타입 오류가 발생하게 된다.  
하위 호환성이 깨지는 변경이 있었다면, 코드가 타입 체커를 통과하더라도 런타임에 오류가 발생할 수 있다.

일반적인 해결책은 타입 선언도 업데이트하여 라이브러리와 버전을 맞추는 것  
타입 선언의 버전이 아직 준비되지 않은 경우 보강 기법을 활용하여 사용하려는 타입 정보를 프로젝트 자체에 추가하거나, 타입 선언의 업데이트를 직접 작성하고 공개하여 커뮤니티에 기여하는 방법이 있다.

### 라이브러리보다 타입 선언이 최신인 경우

이런 경우 타입 정보 없이 라이브러리를 사용해 오다가 타입 선언을 설치하려고 할 때 뒤늦게 발생

타입 체커는 최신 API를 기준으로 코드를 검사하게 되지만 런타임에 실제로 쓰이는 것은 과거 버전  
해결책은 라이브러리와 타입 선언의 버전이 맞도록 라이브러리 버전을 올리거나 타입 선언 버전을 내리는 것

### 프로젝트에서 사용하는 TS 버전보다 라이브러리에서 필요로 하는 TS 버전이 최신인 경우

현재 프로젝트보다 라이브러리에게 필요한 TS 버전이 높은 상황이라면, @types 선언 자체에서 타입 오류가 발생하게 된다.  
이 오류를 해결하려면 프로젝트 TS 버전을 올리거나, 라이브러리 타입 선언의 버전을 원래대로 내리거나, declare module 선언으로 라이브러리의 타입 정보를 없애 버리면 된다.

라이브러리와 타입 선언의 버전을 일치시키는 것이 최선이겠지만, 상황에 따라 해당 버전의 타입 정보가 없을 수도 있다.

### @types 의존성 중복

@types/foo와 @types/bar에 의존하는 경우, 만약 @types/bar가 현재 프로젝트와 호환되지 않는 버전의 @types/foo에 의존한다면 npm은 중첩된 폴더에 별도로 해당 버전을 설치하여 문제를 해결하려고 한다.  
런타임에 사용되는 모듈이라면 괜찮을 수 있지만, 전역 네임스페이스에 있는 타입 선언 모듈이라면 대부분 문제가 발생한다.  
전역 네임스페이스에 타입 선어니 존재하면 중복된 선언, 또는 선언이 병합될 수 없다는 오류가 발생한다.

해결책은 둘 중 하나를 업데이트해서 서로 버전이 호환되게 하는 것이다.

## 타입 선언을 포함(번들링)하는 경우 문제점

자체적 타입 선언은 보통 package.json의 "types" 필드에서 `.d.ts` 파일을 가리키도록 되어 있다.

### 번들된 타입 선언에 보강 기법으로 해결할 수 없는 오류가 있는 경우 or 공개 시점에는 잘 동작했지만 TS 버전이 올라가면서 오류가 발생하는 경우

@types을 별도로 사용하는 경우라면 라이브러리 자체의 버전에 맞추어 선택할 수 있지만, 번들된 타입에서는 버전 선택이 불가능하다.  
단 하나의 잘못된 타입 선언으로 인해 TS 버전을 올리지 못하는 불상사가 생길 수 있는 것이다.

### 프로젝트 내의 타입 선언이 다른 라이브러리의 타입 선언에 의존하는 경우

JS 사용자 입장에서 @types를 설치할 이유가 없기 때문에 다른 라이브러리의 타입 선언을 설치할 이유가 없다.

해결책은 아이템 51장에서..

### 프로젝트의 과거 버전에 있는 타입 선언에 문제가 있는 경우

과거 버전으로 돌아가서 패치 업데이트를 해야 한다.

DefinitelyTyped는 동일 라이브러리의 여러 버전의 타입 선언을 동시에 유지보수할 수 있는 메커니즘을 가지고 있다.

### 타입 선언의 패치 업데이트를 자주 하기 어려움

DefinitelyTyped는 커뮤니티에서 관리되기 때문에 패치 작업량을 감당할 수 있지만, 개별 프로젝트에서는 비슷한 처리 시간을 보장하기 어렵다.

## 결론

TS에서 의존성 관리는 쉽지 않지만, 잘 관리하면 그에 따른 보상이 함께 존재한다.  
잘 작성된 타입 선언은 라이브러리를 올바르게 사용하는 방법을 배우는 데 도움이 되며 생산성 역시 크게 향상시킬 수 있다.  
의존성 관리에 문제가 생긴다면 처음 언급했던 세 가지 버전을 기억해야 한다.

타입스크립트로 작성된 라이브러리라면 타입 선언을 자체적으로 포함하고, 자바스크립트로 작성된 라이브러리라면 타입 선언을 DefinitelyTyped에 공개하는 것이 좋다.

# 공개 API에 등장하는 모든 타입을 익스포트하기

라이브러리 제작자는 프로젝트 초기에 타입 익스포트부터 작성해야 한다.  
함수의 선언에 이미 타입 정보가 있다면 제대로 익스포트되고 있는 것이며, 타입 정보가 없다면 타입을 명시적으로 작성해야 한다.

만약 어떤 타입을 숨기고 싶어서 익스포트하지 않았다고 하더라도, 익스포트된 함수 시그니처에 등장하는 타입들은 추출해 낼 수 있다.  
추출하는 한 가지 방법은 Parameters와 ReturnType 제너릭 타입을 사용하는 것이다.

그렇기 때문에 공개 메서드에 등장한 어떤 형태의 타입이든 익스포트 하는 것이 좋다.  
어차피 라이브러리 사용자가 추출할 수 있으므로, 익스포트하기 쉽게 만드는 것이 좋다.

# API 주석에 TSDoc 사용하기

사용자를 위한 문서라면 JSDoc 스타일의 주석으로 만드는 것이 좋다.  
대부분의 편집기는 함수가 호출되는 곳에서 함수에 붙어 있는 JSDoc 스타일의 주석을 툴팁으로 표시해 주기 때문이다.  
TS 언어 서비스가 JSDoc 스타일을 지원하기 때문에 적극적으로 활용하는 것이 좋다. 만약 공개 API에 주석을 붙인다면 JSDoc 형태로 작성해야 한다.  
타입스크리븥 관점에서는 TSDoc이라고 부르기도 한다.

```typescript
/** 인사말을 생성합니다. 결과는 보기 좋게 꾸며집니다.
 * @param name 인사할 사람의 이름
 * @param title 그 사람의 칭호
 * @returns 사람이 보기 좋은 형태의 인사말
 */
function greet(name: string, title: string) {
  return `Hello ${title} ${name}`;
}
```

타입 정의에 TSDoc을 사용할 수도 있다.

```typescript
/** 특정 시간과 장소에서 수행된 측정 */
type Measurement = {
  /** 어디에서 측정되었나? */
  position: Vector3D;
  /** 언제 측정되었나? epoch에서부터 초 단위로 */
  time: number;
  /** 측정된 운동량 */
  momentum: Vector3D;
};
```

- 각 필드에 마우스를 올려 보면 필드별로 설명을 볼 수 있다.
- TSDoc 주석은 마크다운 형식으로 꾸며지므로 굵은 글씨, 기울임 글씨 등을 사용할 수 있다.
- 주석은 간단히 요점만 언급한다.
- 타입스크립트에서는 타입 정보가 코드에 있기 때문에 타입 정보를 명시하면 안 된다.



# 콜백에서 this에 대한 타입 제공하기

let이나 const로 선언된 변수가 렉시컬 스코프인 반면, this는 다이나믹 스코프이다. 다이나믹 스코프의 값은 정의된 방식이 아니라 호출된 방식에 따라 달라진다.

this 바인딩은 종종 콜백 함수에서 쓰인다.

```typescript
class ResetButton {
  onClick() {
    alert(`Reset ${this}`);
  }
}
```

그러나 onClick을 호출하면, this 바인딩 문제로 인해 경고가 뜬다.

일반적인 해결책은 생성자에서 메서드에 this를 바인딩시키는 것이다.

```typescript
class ResetButton {
  constructor() {
    this.onClick = this.onClick.bind(this);
  }

  onClick() {
    alert(`Reset ${this}`);
  }
}
```

- 생성자에서 위와 같이 바인딩하면, onClick 속성에 this가 바인딩되어 해당 인스턴스에 생성된다.
- 프로퍼티 탐색 순서에서 onClick 인스턴스 속성은 onClick 프로토타입 속성보다 앞에 놓이므로, this.onClick은 바인딩된 함수를 참조하게 된다.
- 더 간단한 방법은 onClick을 화살표 함수로 바꾸는 것이다.

타입스크립트 역시 this 바인딩을 그대로 모델링하게 된다. 만약 작성 중인 라이브러리에 this를 사용하는 콜백 함수가 있다면, this 바인딩 문제를 고려해야 한다.  
이 문제는 콜백 함수의 매개변수에 this를 추가하고, 콜백 함수를 call로 호출해서 해결할 수 있다.

```typescript
function addKeyListener(
  el: HTMLElement,
  fn: (this: HTMLElement, e: KeyboardEvent) => void
) {
  el.addEventListener("keydown", (e) => {
    fn.call(el, e);
  });
}
```

- 콜백 함수의 첫 번째 매개변수에 있는 this는 특별하게 처리된다.
- call을 제거하고 사용하면 타입 에러가 발생하고, this 바인딩도 체크해준다.
- 그리고 라이브러리 사용자의 콜백 함수에서 this를 참조할 수 있고 완전한 타입 안정성도 얻을 수 있다.
- 만약 라이브러리 사용자가 콜백을 화살표 함수로 작성하고 this를 참조하려고 하면 타입스크립트가 문제를 잡아낸다.
- 이처럼 콜백 함수에서 this 값을 사용해야 한다면 this는 API의 일부가 되는 것이기 때문에 반드시 선언 타입에 포함해야 한다.

# 오버로딩 타입보다는 조건부 타입을 사용하기

string 또는 number 타입의 매개변수가 들어올 수 있는 double 함수에 타입 정보를 추가해보자  
이때 함수 오버로딩 개념을 사용했다.

```typescript
function double(x: number | string): number | string;
function double(x: any) {
  return x + x;
}
```

- double에 number 타입을 매개변수를 넣으면 number 타입을 반환해야 하지만 선언문에는 number 타입을 매개변수로 넣고 string 타입을 반환하는 경우도 포함되어 있다.
- 제너릭을 사용하면 이러한 동작을 모델링 할 수 있지만, 타입이 너무 과하게 구체적이다. string 타입을 매개변수로 넘기면 string 타입이 반환되어야 한다.

또 다른 방법은 여러 가지 타입 선언으로 분리하는 것이다.  
타입스크립트에서 함수의 구현체는 하나지만, 타입 선언은 몇 개든지 만들 수 있다.

```typescript
function double(x: number): number;
function double(x: string): string;
function double(x: any) {
  return x + x;
}
```

- 이를 활용하여 double의 타입을 개선할 수 있지만, 아직도 버그는 남아 있다.
- string이나 number 타입의 값으로는 잘 동작하지만, 유니온 타입 관련해서 문제가 발생한다.
- 세 번째 오버로딩을 추가하여 문제를 해결할 수도 있지만, 가장 좋은 해결책은 조건부 타입을 사용하는 것이다.

```typescript
function double<T extends number | string>(
  x: T
): T extends string ? string : number;
function double(x: any) {
  return x + x;
}
```

- 이 코드는 제너릭을 사용했던 방법과 유사하지만, 반환 타입이 더 정교하다.
- 조건부 타입은 삼항 연산자처럼 사용하면 된다.
- T가 string의 부분집합이면, 반환 타입이 string이고 그 외의 경우는 반환 타입이 number이다.

## 결론

- 유니온에 조건부 타입을 적용하면, 조건부 타입의 유니온으로 분리되기 때문에 동작한다.
- 오버로딩 타입이 작성하기는 쉽지만, 조건부 타입은 개별 타입의 유니온으로 일반화하기 때문에 타입이 더 정확해진다.
- 오버로딩 타입을 작성하는 경우, 조건부 타입을 사용해서 개선할 수 있을지 검토해 보는 것이 좋다.
